import { access, copyFile, open as openFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { spawn } from "node:child_process";

function printUsage() {
  console.log([
    "Usage:",
    "  npm run dev:world -- --file /path/to/world.(ply|glb|fbx)",
    "",
    "Optional extra Vite args:",
    "  npm run dev:world -- --file /path/to/world.ply --host --port 5174",
  ].join("\n"));
}

function parseArgs(argv) {
  let inputFile = "";
  const viteArgs = [];

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (arg === "--help" || arg === "-h") {
      printUsage();
      process.exit(0);
    }
    if (arg === "--file") {
      const next = argv[i + 1];
      if (!next || next.startsWith("--")) {
        console.error("Error: --file requires a path value.");
        printUsage();
        process.exit(1);
      }
      inputFile = next;
      i += 1;
      continue;
    }
    viteArgs.push(arg);
  }

  if (!inputFile) {
    console.error("Error: Missing required --file argument.");
    printUsage();
    process.exit(1);
  }

  return { inputFile, viteArgs };
}

async function readHeader(filePath, byteCount = 128 * 1024) {
  const handle = await openFile(filePath, "r");
  try {
    const buffer = Buffer.alloc(byteCount);
    const { bytesRead } = await handle.read(buffer, 0, byteCount, 0);
    return buffer.subarray(0, bytesRead).toString("latin1");
  } finally {
    await handle.close();
  }
}

function classifyPlyFromHeader(headerText) {
  const faceMatch = headerText.match(/element\s+face\s+(\d+)/i);
  const faceCount = faceMatch ? Number(faceMatch[1]) : 0;
  const lower = headerText.toLowerCase();
  const isGaussianSplat =
    lower.includes("generated by nerstudio") ||
    (lower.includes("f_dc_0") && lower.includes("opacity") && lower.includes("scale_0"));

  if (isGaussianSplat) {
    return { kind: "gaussian-point-cloud", faceCount };
  }
  if (faceCount > 0) {
    return { kind: "mesh-ply", faceCount };
  }
  return { kind: "point-cloud-ply", faceCount: 0 };
}

async function main() {
  const { inputFile, viteArgs } = parseArgs(process.argv.slice(2));

  const thisDir = path.dirname(fileURLToPath(import.meta.url));
  const source = path.resolve(process.cwd(), inputFile);
  const ext = path.extname(source).toLowerCase();
  const viteBin = path.resolve(thisDir, "node_modules", "vite", "bin", "vite.js");

  try {
    await access(source);
  } catch {
    console.error(`Error: File not found: ${source}`);
    process.exit(1);
  }

  try {
    await access(viteBin);
  } catch {
    console.error("Error: Vite binary not found. Run `npm install` in viewer first.");
    process.exit(1);
  }

  let openPath = "/";
  if (ext === ".ply") {
    const target = path.resolve(thisDir, "public", "model.ply");
    await copyFile(source, target);
    const header = await readHeader(source);
    const classification = classifyPlyFromHeader(header);
    console.log(`Copied PLY:\n  from ${source}\n  to   ${target}`);
    console.log(`Detected file type: ${classification.kind} (faces=${classification.faceCount.toLocaleString()})`);
    openPath = "/";
  } else if (ext === ".glb") {
    const target = path.resolve(thisDir, "public", "model.glb");
    await copyFile(source, target);
    console.log(`Copied GLB:\n  from ${source}\n  to   ${target}`);
    console.log("Detected file type: glb-mesh");
    openPath = "/index_glb.html";
  } else if (ext === ".fbx") {
    const target = path.resolve(thisDir, "public", "model.fbx");
    await copyFile(source, target);
    console.log(`Copied FBX:\n  from ${source}\n  to   ${target}`);
    console.log("Detected file type: fbx-mesh");
    openPath = "/index_fbx.html";
  } else {
    console.error(`Error: Unsupported extension "${ext}". Use .ply, .glb, or .fbx.`);
    process.exit(1);
  }

  console.log(`Open ${openPath} after Vite starts.`);

  const child = spawn(process.execPath, [viteBin, ...viteArgs], {
    stdio: "inherit",
    cwd: thisDir,
  });

  child.on("exit", (code) => process.exit(code ?? 0));
}

main().catch((error) => {
  console.error("Failed to start viewer:", error);
  process.exit(1);
});
