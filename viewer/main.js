import * as THREE from "three";
import { PointerLockControls } from "three/examples/jsm/controls/PointerLockControls.js";
import { PLYLoader } from "three/examples/jsm/loaders/PLYLoader.js";

const statusEl = document.getElementById("status");
const fileInput = document.getElementById("fileInput");
const overlay = document.getElementById("overlay");
const enterButton = document.getElementById("enterButton");

let preferCleanView = true;
let currentHasVertexColor = false;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0e1116);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 5000);
camera.position.set(0, 1.5, 3);

const controls = new PointerLockControls(camera, document.body);

scene.add(new THREE.HemisphereLight(0xffffff, 0x445066, 0.85));
scene.add(new THREE.AmbientLight(0xffffff, 0.35));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.75);
dirLight.position.set(3, 5, 2);
scene.add(dirLight);

const grid = new THREE.GridHelper(20, 20, 0x3a4558, 0x252c38);
grid.position.y = -0.001;
scene.add(grid);

let currentMesh = null;
const loader = new PLYLoader();
const FIXED_ROT_X = -Math.PI / 2; // fixed default orientation
const HEADER_SCAN_BYTES = 64 * 1024;
const SH_C0 = 0.28209479177387814;
const POINT_DENSITY_MULTIPLIER_RAW = 1.6;
const POINT_DENSITY_MULTIPLIER_SPLAT = 1.35;
const POINT_DENSITY_SCALE_MIN = 0.5;
const POINT_DENSITY_SCALE_MAX = 2.5;
let pointDensityScale = 1.0;

const keyState = new Map();
const moveForward = new THREE.Vector3();
const moveRight = new THREE.Vector3();
const WORLD_UP = new THREE.Vector3(0, 1, 0);
let lastTime = performance.now();

const baseSpeed = 3.0;
const sprintMultiplier = 2.0;
const verticalSpeed = 2.8;

function setStatus(text) {
  statusEl.textContent = text;
}

function isViewerLocked() {
  const pe = document.pointerLockElement;
  return controls.isLocked || pe === document.body || pe === renderer.domElement;
}

function updateOverlay() {
  overlay.classList.toggle("hidden", isViewerLocked());
}

function isPressed(code) {
  return keyState.get(code) === true;
}

function disposeCurrentMesh() {
  if (!currentMesh) return;
  scene.remove(currentMesh);
  if (currentMesh.geometry) currentMesh.geometry.dispose();
  if (Array.isArray(currentMesh.material)) {
    currentMesh.material.forEach((m) => m.dispose());
  } else if (currentMesh.material) {
    currentMesh.material.dispose();
  }
  currentMesh = null;
}

function applySceneRotation() {
  if (!currentMesh) return;
  currentMesh.rotation.set(FIXED_ROT_X, 0, 0);
  currentMesh.updateMatrixWorld(true);
}

function fitCameraToMesh(mesh) {
  const box = new THREE.Box3().setFromObject(mesh);
  if (box.isEmpty()) return;

  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const radius = Math.max(size.length() * 0.5, 1e-4);

  const fovRad = THREE.MathUtils.degToRad(camera.fov);
  const dist = radius / Math.tan(fovRad / 2);
  const distance = dist * 1.2;

  const dir = new THREE.Vector3(1, 0.5, 1).normalize();
  camera.position.copy(center).addScaledVector(dir, distance);

  camera.near = Math.max(radius / 1000, 0.001);
  camera.far = Math.max(radius * 20, 1000);
  camera.updateProjectionMatrix();

  camera.lookAt(center);
}

function readPlyHeader(arrayBuffer) {
  const byteCount = Math.min(arrayBuffer.byteLength, HEADER_SCAN_BYTES);
  const headerChunk = new Uint8Array(arrayBuffer, 0, byteCount);
  const headerText = new TextDecoder("latin1").decode(headerChunk);
  const endMarker = "end_header";
  const endIndex = headerText.indexOf(endMarker);
  return endIndex >= 0 ? headerText.slice(0, endIndex + endMarker.length) : headerText;
}

function parseFaceCountFromHeader(headerText) {
  const match = headerText.match(/element\s+face\s+(\d+)/i);
  return match ? Number(match[1]) : 0;
}

function isNerfstudioSplatHeader(headerText) {
  const h = headerText.toLowerCase();
  return h.includes("generated by nerstudio") || (h.includes("f_dc_0") && h.includes("opacity") && h.includes("scale_0"));
}

function clamp01(v) {
  return Math.min(1, Math.max(0, v));
}

function sigmoid(x) {
  if (x >= 0) {
    const z = Math.exp(-x);
    return 1 / (1 + z);
  }
  const z = Math.exp(x);
  return z / (1 + z);
}

function estimateColorScale(colorAttr) {
  if (!colorAttr || colorAttr.count === 0) return 1;
  const sampleCount = Math.min(colorAttr.count, 4096);
  let maxValue = 0;
  const stride = Math.max(1, Math.floor(colorAttr.count / sampleCount));
  for (let i = 0; i < colorAttr.count; i += stride) {
    maxValue = Math.max(maxValue, colorAttr.getX(i), colorAttr.getY(i), colorAttr.getZ(i));
  }
  return maxValue > 1.5 ? 255 : 1;
}

function computePointSize(geometry, hasSplatScales) {
  if (!geometry.boundingBox) geometry.computeBoundingBox();
  const bbox = geometry.boundingBox;
  if (!bbox || bbox.isEmpty()) return 0.01;
  const diag = bbox.getSize(new THREE.Vector3()).length();
  const base = hasSplatScales ? diag * 0.0018 : diag * 0.001;
  const multiplier = hasSplatScales ? POINT_DENSITY_MULTIPLIER_SPLAT : POINT_DENSITY_MULTIPLIER_RAW;
  return THREE.MathUtils.clamp(base * multiplier, 0.001, 0.12);
}

function applyPointDensityScale() {
  if (!currentMesh?.isPoints || !currentMesh.material) return;
  const baseSize = currentMesh.userData?.basePointSize;
  if (!Number.isFinite(baseSize)) return;
  currentMesh.material.size = THREE.MathUtils.clamp(baseSize * pointDensityScale, 0.001, 0.2);
  currentMesh.material.needsUpdate = true;
}

function recomputeAndSanitizeNormals(geometry) {
  geometry.deleteAttribute("normal");
  geometry.computeVertexNormals();

  const normal = geometry.getAttribute("normal");
  if (!normal) return;
  for (let i = 0; i < normal.count; i += 1) {
    const nx = normal.getX(i);
    const ny = normal.getY(i);
    const nz = normal.getZ(i);
    if (!Number.isFinite(nx) || !Number.isFinite(ny) || !Number.isFinite(nz)) {
      normal.setXYZ(i, 0, 1, 0);
    }
  }
  normal.needsUpdate = true;
}

function denoiseSparseBlackVertexColors(color) {
  if (!color) return 0;

  let maxValue = 0;
  for (let i = 0; i < color.count; i += 1) {
    maxValue = Math.max(maxValue, color.getX(i), color.getY(i), color.getZ(i));
  }
  const scale = maxValue > 1.5 ? 255.0 : 1.0;
  const blackThreshold = 0.02 * scale;
  const liftValue = 0.10 * scale;

  const darkIdx = [];
  for (let i = 0; i < color.count; i += 1) {
    const r = color.getX(i);
    const g = color.getY(i);
    const b = color.getZ(i);
    const luma = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    if (luma < blackThreshold) darkIdx.push(i);
  }

  if (darkIdx.length === 0) return 0;
  if (darkIdx.length / color.count > 0.02) return 0;

  for (const i of darkIdx) {
    color.setXYZ(i, liftValue, liftValue, liftValue);
  }
  color.needsUpdate = true;
  return darkIdx.length;
}

function smoothTriangleColorOutliers(geometry, color) {
  if (!color) return 0;

  const maxValue = (() => {
    let v = 0;
    for (let i = 0; i < color.count; i += 1) {
      v = Math.max(v, color.getX(i), color.getY(i), color.getZ(i));
    }
    return v;
  })();
  const scale = maxValue > 1.5 ? 255.0 : 1.0;
  const dark = 0.12 * scale;
  const bright = 0.98 * scale;
  const outlierThreshold = 0.22 * scale;
  const blend = 0.7;

  const index = geometry.index?.array;
  const vertexCount = geometry.attributes.position?.count ?? 0;
  let changed = 0;

  const processTri = (ia, ib, ic) => {
    const ca = [color.getX(ia), color.getY(ia), color.getZ(ia)];
    const cb = [color.getX(ib), color.getY(ib), color.getZ(ib)];
    const cc = [color.getX(ic), color.getY(ic), color.getZ(ic)];

    const luma = (c) => 0.2126 * c[0] + 0.7152 * c[1] + 0.0722 * c[2];
    const dist = (u, v) => Math.hypot(u[0] - v[0], u[1] - v[1], u[2] - v[2]);
    const avg = (u, v) => [(u[0] + v[0]) * 0.5, (u[1] + v[1]) * 0.5, (u[2] + v[2]) * 0.5];
    const blendTo = (from, to) => [
      from[0] + (to[0] - from[0]) * blend,
      from[1] + (to[1] - from[1]) * blend,
      from[2] + (to[2] - from[2]) * blend,
    ];

    const fix = (idx, cSelf, cU, cV) => {
      const lu = luma(cSelf);
      const target = avg(cU, cV);
      if (dist(cSelf, target) > outlierThreshold && (lu < dark || lu > bright)) {
        const cNew = blendTo(cSelf, target);
        color.setXYZ(idx, cNew[0], cNew[1], cNew[2]);
        changed += 1;
      }
    };

    fix(ia, ca, cb, cc);
    fix(ib, cb, ca, cc);
    fix(ic, cc, ca, cb);
  };

  if (index && index.length >= 3) {
    for (let i = 0; i + 2 < index.length; i += 3) {
      processTri(index[i], index[i + 1], index[i + 2]);
    }
  } else {
    for (let i = 0; i + 2 < vertexCount; i += 3) {
      processTri(i, i + 1, i + 2);
    }
  }

  color.needsUpdate = true;
  return changed;
}

function prepareColorModes(geometry) {
  const raw = geometry.getAttribute("color");
  if (!raw) return { hasColor: false, cleanedCount: 0 };

  const rawAttr = raw.clone();
  const cleanAttr = raw.clone();
  const darkSpeckles = denoiseSparseBlackVertexColors(cleanAttr);
  const triSpeckles = smoothTriangleColorOutliers(geometry, cleanAttr);

  geometry.setAttribute("color_raw", rawAttr);
  geometry.setAttribute("color_clean", cleanAttr);
  geometry.setAttribute("color", preferCleanView ? cleanAttr : rawAttr);
  return { hasColor: true, cleanedCount: darkSpeckles + triSpeckles };
}

function buildMeshFromGeometry(geometry) {
  recomputeAndSanitizeNormals(geometry);
  geometry.computeBoundingBox();

  const { hasColor, cleanedCount } = prepareColorModes(geometry);
  currentHasVertexColor = hasColor;

  const material = new THREE.MeshLambertMaterial({
    color: hasColor ? 0xffffff : 0xbac2cd,
    vertexColors: hasColor,
    side: THREE.FrontSide,
  });

  const mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  return { object: mesh, denoisedCount: cleanedCount, denoiseLabel: "color outliers", renderMode: "mesh" };
}

function buildPointCloudFromGeometry(geometry, { isSplatLike }) {
  geometry.computeBoundingBox();

  const position = geometry.getAttribute("position");
  if (!position) {
    const empty = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({ color: 0xbac2cd, size: 0.01 }));
    return { object: empty, denoisedCount: 0, denoiseLabel: "points", renderMode: "points" };
  }

  const count = position.count;
  const rawColor = geometry.getAttribute("color");
  const opacity = geometry.getAttribute("opacity");
  const sh0 = geometry.getAttribute("f_dc_0");
  const sh1 = geometry.getAttribute("f_dc_1");
  const sh2 = geometry.getAttribute("f_dc_2");

  const colorScale = estimateColorScale(rawColor);
  const hasSHColor = Boolean(sh0 && sh1 && sh2);

  const positions = new Float32Array(count * 3);
  const colors = new Float32Array(count * 3);
  let writeCount = 0;
  let removedOpacity = 0;

  for (let i = 0; i < count; i += 1) {
    if (opacity) {
      const alpha = sigmoid(opacity.getX(i));
      if (alpha <= 0.02) {
        removedOpacity += 1;
        continue;
      }
    }

    const w = writeCount * 3;
    positions[w] = position.getX(i);
    positions[w + 1] = position.getY(i);
    positions[w + 2] = position.getZ(i);

    if (hasSHColor) {
      colors[w] = clamp01(0.5 + SH_C0 * sh0.getX(i));
      colors[w + 1] = clamp01(0.5 + SH_C0 * sh1.getX(i));
      colors[w + 2] = clamp01(0.5 + SH_C0 * sh2.getX(i));
    } else if (rawColor) {
      colors[w] = clamp01(rawColor.getX(i) / colorScale);
      colors[w + 1] = clamp01(rawColor.getY(i) / colorScale);
      colors[w + 2] = clamp01(rawColor.getZ(i) / colorScale);
    } else {
      colors[w] = 0.82;
      colors[w + 1] = 0.84;
      colors[w + 2] = 0.88;
    }

    writeCount += 1;
  }

  const finalPositions = writeCount === count ? positions : positions.slice(0, writeCount * 3);
  const finalColors = writeCount === count ? colors : colors.slice(0, writeCount * 3);

  const pointsGeometry = new THREE.BufferGeometry();
  pointsGeometry.setAttribute("position", new THREE.Float32BufferAttribute(finalPositions, 3));
  pointsGeometry.setAttribute("color", new THREE.Float32BufferAttribute(finalColors, 3));
  pointsGeometry.computeBoundingBox();
  pointsGeometry.computeBoundingSphere();

  const hasSplatScales = Boolean(
    geometry.getAttribute("scale_0") && geometry.getAttribute("scale_1") && geometry.getAttribute("scale_2"),
  );
  const pointSize = computePointSize(pointsGeometry, hasSplatScales);

  const material = new THREE.PointsMaterial({
    size: pointSize,
    sizeAttenuation: true,
    vertexColors: true,
    transparent: true,
    opacity: isSplatLike ? 0.95 : 1.0,
    depthWrite: false,
  });

  const points = new THREE.Points(pointsGeometry, material);
  points.frustumCulled = false;
  points.castShadow = false;
  points.receiveShadow = false;
  points.userData.basePointSize = pointSize;

  return {
    object: points,
    denoisedCount: removedOpacity,
    denoiseLabel: "low-opacity points",
    renderMode: isSplatLike ? "gaussian-points" : "point-cloud",
  };
}

function loadGeometryFromArrayBuffer(arrayBuffer, label) {
  const header = readPlyHeader(arrayBuffer);
  const faceCount = parseFaceCountFromHeader(header);
  const headerSplat = isNerfstudioSplatHeader(header);
  const geometry = loader.parse(arrayBuffer);

  const hasIndexFaces = Boolean(geometry.index && geometry.index.count >= 3);
  const attrNames = Object.keys(geometry.attributes ?? {});
  const attrSplat = attrNames.includes("f_dc_0") && attrNames.includes("opacity") && attrNames.includes("scale_0");
  const isSplatLike = headerSplat || attrSplat;
  const shouldRenderAsMesh = faceCount > 0 || hasIndexFaces;
  const { object, denoisedCount, denoiseLabel, renderMode } = shouldRenderAsMesh
    ? buildMeshFromGeometry(geometry)
    : buildPointCloudFromGeometry(geometry, { isSplatLike });

  disposeCurrentMesh();
  currentMesh = object;
  scene.add(object);
  applySceneRotation();
  fitCameraToMesh(object);
  applyPointDensityScale();

  const count = geometry.attributes.position?.count ?? 0;
  const mode = shouldRenderAsMesh && currentHasVertexColor ? (preferCleanView ? "clean-color" : "raw-color") : renderMode;
  const denoiseSuffix = denoisedCount > 0 ? `, cleaned ${denoisedCount.toLocaleString()} ${denoiseLabel}` : "";
  const rotDeg = Math.round((FIXED_ROT_X * 180) / Math.PI);
  setStatus(
    `Loaded ${label} (${count.toLocaleString()} vertices, mode=${mode}, faces=${faceCount.toLocaleString()}, rotX=${rotDeg}deg${denoiseSuffix})`,
  );
}

async function loadDefaultModel() {
  try {
    const response = await fetch("/model.ply", { cache: "no-store" });
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const buffer = await response.arrayBuffer();
    loadGeometryFromArrayBuffer(buffer, "/model.ply");
  } catch (error) {
    setStatus("Could not load /model.ply. Use 'Open PLY' or drag/drop a file.");
    console.error(error);
  }
}

function updateMovement(dt) {
  if (!isViewerLocked()) {
    return;
  }

  camera.getWorldDirection(moveForward);
  moveForward.y = 0;
  if (moveForward.lengthSq() > 1e-8) moveForward.normalize();
  moveRight.crossVectors(moveForward, WORLD_UP).normalize();

  const inputX = Number(isPressed("KeyD")) - Number(isPressed("KeyA"));
  const inputZ = Number(isPressed("KeyW")) - Number(isPressed("KeyS"));

  const direction = new THREE.Vector3();
  direction.addScaledVector(moveRight, inputX);
  direction.addScaledVector(moveForward, inputZ);
  if (direction.lengthSq() > 0) direction.normalize();

  const sprint = isPressed("ShiftLeft") || isPressed("ShiftRight");
  const speed = baseSpeed * (sprint ? sprintMultiplier : 1.0);
  const horiz = direction.multiplyScalar(speed);

  // Flight controls: E up, C down.
  let vY = 0.0;
  if (isPressed("KeyE")) {
    vY = verticalSpeed * (sprint ? sprintMultiplier : 1.0);
  } else if (isPressed("KeyC")) {
    vY = -verticalSpeed * (sprint ? sprintMultiplier : 1.0);
  }

  // No input -> no movement (no drift).
  camera.position.x += horiz.x * dt;
  camera.position.z += horiz.z * dt;
  camera.position.y += vY * dt;
}

fileInput.addEventListener("change", async (event) => {
  const file = event.target.files?.[0];
  if (!file) return;
  try {
    const buf = await file.arrayBuffer();
    loadGeometryFromArrayBuffer(buf, file.name);
  } catch (error) {
    setStatus(`Failed to load ${file.name}`);
    console.error(error);
  }
});

window.addEventListener("dragover", (event) => {
  event.preventDefault();
});

window.addEventListener("drop", async (event) => {
  event.preventDefault();
  const file = event.dataTransfer?.files?.[0];
  if (!file) return;
  if (!file.name.toLowerCase().endsWith(".ply")) {
    setStatus("Drop a .ply file.");
    return;
  }
  try {
    const buf = await file.arrayBuffer();
    loadGeometryFromArrayBuffer(buf, file.name);
  } catch (error) {
    setStatus(`Failed to load ${file.name}`);
    console.error(error);
  }
});

window.addEventListener("keydown", (event) => {
  keyState.set(event.code, true);

  if (event.code === "BracketLeft") {
    pointDensityScale = Math.max(POINT_DENSITY_SCALE_MIN, pointDensityScale * 0.85);
    applyPointDensityScale();
    setStatus(`Point density: ${(pointDensityScale * 100).toFixed(0)}%`);
    return;
  }
  if (event.code === "BracketRight") {
    pointDensityScale = Math.min(POINT_DENSITY_SCALE_MAX, pointDensityScale * 1.15);
    applyPointDensityScale();
    setStatus(`Point density: ${(pointDensityScale * 100).toFixed(0)}%`);
    return;
  }

  if (event.code === "KeyT") {
    preferCleanView = !preferCleanView;
    if (!currentMesh) return;

    const hasRaw = currentMesh.geometry?.hasAttribute("color_raw") ?? false;
    const hasClean = currentMesh.geometry?.hasAttribute("color_clean") ?? false;
    if (!hasRaw || !hasClean) {
      setStatus("Clean/raw toggle is only available for mesh vertex colors.");
      return;
    }

    const raw = currentMesh.geometry.getAttribute("color_raw");
    const clean = currentMesh.geometry.getAttribute("color_clean");
    if (raw && clean) {
      currentMesh.geometry.setAttribute("color", preferCleanView ? clean : raw);
      currentMesh.geometry.attributes.color.needsUpdate = true;
    }

    setStatus(`View mode: ${preferCleanView ? "clean-color" : "raw-color"}`);
  }

});

window.addEventListener("keyup", (event) => {
  keyState.set(event.code, false);
});

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

enterButton.addEventListener("click", () => {
  // Enter button is the activation control for pointer lock.
  overlay.classList.add("hidden");
  controls.lock();
});
document.addEventListener("pointerlockchange", updateOverlay);
document.addEventListener("pointerlockerror", () => {
  setStatus("Pointer lock failed. Click 'Click to enter' again.");
  updateOverlay();
});
controls.addEventListener("lock", updateOverlay);
controls.addEventListener("unlock", updateOverlay);
updateOverlay();

function animate(now) {
  const dt = Math.min((now - lastTime) / 1000.0, 0.1);
  lastTime = now;

  updateMovement(dt);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

loadDefaultModel();
requestAnimationFrame(animate);
